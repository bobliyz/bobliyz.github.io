<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bob个人博客</title>
  <icon>https://www.gravatar.com/avatar/d28f026fef9f4031e21c0e62ceaf9547</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bobliyz.github.io/"/>
  <updated>2018-07-18T08:58:40.826Z</updated>
  <id>https://bobliyz.github.io/</id>
  
  <author>
    <name>bob</name>
    <email>353136823@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sinopia搭建私有npm库</title>
    <link href="https://bobliyz.github.io/2018/07/18/sinopia%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89npm%E5%BA%93/"/>
    <id>https://bobliyz.github.io/2018/07/18/sinopia搭建私有npm库/</id>
    <published>2018-07-18T08:58:13.000Z</published>
    <updated>2018-07-18T08:58:40.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><ol><li>配置较简单</li><li>sinopia拥有内置数据库</li><li>自动匹配策略（源为sinopia时，本地无安装包时，先从本地找，在去原npm找）</li></ol><h3 id="1-安装sinopia"><a href="#1-安装sinopia" class="headerlink" title="1.安装sinopia"></a>1.安装sinopia</h3><p>全局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i sinopia -g</span><br></pre></td></tr></table></figure></p><h3 id="2-启动sinopia"><a href="#2-启动sinopia" class="headerlink" title="2.启动sinopia"></a>2.启动sinopia</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinopia</span><br></pre></td></tr></table></figure><p>启动成功后的打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> at Module._compile (module.js:573:32)</span><br><span class="line">    at Object.Module._extensions..js (module.js:582:10)</span><br><span class="line">    at Module.load (module.js:490:32)</span><br><span class="line">    at tryModuleLoad (module.js:449:12)</span><br><span class="line">    at Function.Module._load (module.js:441:3) code: &apos;MODULE_NOT_FOUND&apos; &#125;</span><br><span class="line"> warn  --- config file  - /Users/用户/.config/sinopia/config.yaml</span><br><span class="line"> warn  --- http address - http://localhost:4873/</span><br><span class="line"> http  &lt;-- 200, user: undefined, req: &apos;GET /&apos;, bytes: 0/1407</span><br><span class="line">(node:2213) DeprecationWarning: Using Buffer without `new` will soon stop working. Use `new Buffer()`, or preferably `Buffer.from()`, `Buffer.allocUnsafe()` or `Buffer.alloc()` instead.</span><br><span class="line"> http  &lt;-- 304, user: undefined, req: &apos;GET /-/static/jquery.min.js&apos;, bytes: 0/0</span><br><span class="line"> http  &lt;-- 304, user: undefined, req: &apos;GET /-/static/main.js&apos;, bytes: 0/0</span><br><span class="line"> http  &lt;-- 200, user: undefined, req: &apos;GET /-/static/main.css&apos;, bytes: 0/26196</span><br><span class="line"> http  &lt;-- 200, user: undefined, req: &apos;GET /-/logo&apos;, bytes: 0/3447</span><br><span class="line"> http  &lt;-- 200, user: undefined, req: &apos;GET /-/static/fontello.woff?10872183&apos;, bytes: 0/2844</span><br></pre></td></tr></table></figure></p><p>==在mac上的路径：用户/.config/sinopia/config.yaml==</p><p>config.yaml文件在sinopia的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># This is the default config file. It allows all users to do anything,</span><br><span class="line"># so don&apos;t use it on production systems.</span><br><span class="line">#</span><br><span class="line"># Look here for more config file examples:</span><br><span class="line"># https://github.com/rlidwka/sinopia/tree/master/conf</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># path to a directory with all packages</span><br><span class="line">storage: /Users/用户/.local/share/sinopia/storage #npm包存放的路径</span><br><span class="line"></span><br><span class="line">auth:</span><br><span class="line">  htpasswd:</span><br><span class="line">    file: ./htpasswd #保存用户的账号密码等信息</span><br><span class="line">    # Maximum amount of users allowed to register, defaults to &quot;+inf&quot;.</span><br><span class="line">    # You can set this to -1 to disable registration.</span><br><span class="line">    max_users: -1 #默认为1000，改为-1，禁止注册</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># a list of other known repositories we can talk to</span><br><span class="line">uplinks:</span><br><span class="line">  npmjs:</span><br><span class="line">    url: https://registry.npmjs.org/#默认为npm的官网</span><br><span class="line">#配置权限管理</span><br><span class="line">packages:</span><br><span class="line">  &apos;@*/*&apos;:</span><br><span class="line">    # scoped packages</span><br><span class="line">    access: $all</span><br><span class="line">    publish: $authenticated</span><br><span class="line"></span><br><span class="line">  &apos;*&apos;:</span><br><span class="line">    # allow all users (including non-authenticated users) to read and</span><br><span class="line">    # publish all packages</span><br><span class="line">    #</span><br><span class="line">    # you can specify usernames/groupnames (depending on your auth plugin)</span><br><span class="line">    # and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;</span><br><span class="line">    access: $all</span><br><span class="line"></span><br><span class="line">    # allow all known users to publish packages</span><br><span class="line">    # (anyone can register by default, remember?)</span><br><span class="line">    publish: $authenticated</span><br><span class="line"></span><br><span class="line">    # if package is not available locally, proxy requests to &apos;npmjs&apos; registry</span><br><span class="line">    proxy: npmjs</span><br><span class="line"></span><br><span class="line"># log settings</span><br><span class="line">logs:</span><br><span class="line">  - &#123;type: stdout, format: pretty, level: http&#125;</span><br><span class="line">  #- &#123;type: file, path: sinopia.log, level: info&#125;</span><br><span class="line">listen: 0.0.0.0:4873  ##默认没有，只能在本机访问，添加后可以通过外网访问</span><br></pre></td></tr></table></figure></p><h3 id="3-Sinopia的使用"><a href="#3-Sinopia的使用" class="headerlink" title="3.Sinopia的使用"></a>3.Sinopia的使用</h3><h5 id="使用nrm来管理自己的npm代理"><a href="#使用nrm来管理自己的npm代理" class="headerlink" title="- 使用nrm来管理自己的npm代理"></a>- 使用nrm来管理自己的npm代理</h5><h6 id="好处：nrm可以快速修改-切换-增加npm镜像地址。"><a href="#好处：nrm可以快速修改-切换-增加npm镜像地址。" class="headerlink" title="好处：nrm可以快速修改,切换,增加npm镜像地址。"></a>好处：nrm可以快速修改,切换,增加npm镜像地址。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nrm # 安装nrm</span><br><span class="line">nrm add sinopia http://10.10.13.15:4873 # 添加新搭建的npm私有仓库地址</span><br><span class="line">nrm use sinopia</span><br></pre></td></tr></table></figure><h6 id="nrm的其他命令："><a href="#nrm的其他命令：" class="headerlink" title="nrm的其他命令："></a>nrm的其他命令：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nrm --help  # 查看nrm命令帮助</span><br><span class="line">nrm list/nrm ls # 列出可用的 npm 镜像地址</span><br><span class="line">nrm use taobao # 使用`淘宝npm`镜像地址</span><br></pre></td></tr></table></figure><h6 id="解决端口-4873-占用问题"><a href="#解决端口-4873-占用问题" class="headerlink" title="解决端口 4873 占用问题"></a>解决端口 4873 占用问题</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 安装 lsof 命令</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install lsof</span><br><span class="line"></span><br><span class="line"># 查看端口占用进程 PID</span><br><span class="line">lsof -i :4873</span><br><span class="line"></span><br><span class="line"># 杀死占用 4873 端口的进程。4649，要换为实际的 PID。</span><br><span class="line">kill -9 4649</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;优势&quot;&gt;&lt;a href=&quot;#优势&quot; class=&quot;headerlink&quot; title=&quot;优势&quot;&gt;&lt;/a&gt;优势&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;配置较简单&lt;/li&gt;
&lt;li&gt;sinopia拥有内置数据库&lt;/li&gt;
&lt;li&gt;自动匹配策略（源为sinopia时，本地无安装包时
      
    
    </summary>
    
      <category term="node npm" scheme="https://bobliyz.github.io/categories/node-npm/"/>
    
    
  </entry>
  
  <entry>
    <title>设置npm-registry</title>
    <link href="https://bobliyz.github.io/2018/07/18/%E8%AE%BE%E7%BD%AEnpm-registry/"/>
    <id>https://bobliyz.github.io/2018/07/18/设置npm-registry/</id>
    <published>2018-07-18T03:03:38.000Z</published>
    <updated>2018-07-18T03:11:32.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-npm原地址"><a href="#1-npm原地址" class="headerlink" title="1. npm原地址"></a>1. npm原地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http://registry.npmjs.org</span><br></pre></td></tr></table></figure><h2 id="2-国内镜像"><a href="#2-国内镜像" class="headerlink" title="2.国内镜像"></a>2.国内镜像</h2><ul><li>通过config命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line">npm info underscore （如果上面配置正确这个命令会有字符串response）</span><br></pre></td></tr></table></figure><ul><li>命令行指定</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --registry https://registry.npm.taobao.org info underscore</span><br></pre></td></tr></table></figure><ul><li>编辑 ~/.npmrc 加入下面内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry = https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="3-使用nrm管理registry地址"><a href="#3-使用nrm管理registry地址" class="headerlink" title="3.使用nrm管理registry地址"></a>3.使用nrm管理registry地址</h2><ul><li>添加registry地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm add npm http://registry.npmjs.org</span><br><span class="line">nrm add taobao https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><ul><li>切换npm registry地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm use taobao</span><br><span class="line">nrm use npm</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-npm原地址&quot;&gt;&lt;a href=&quot;#1-npm原地址&quot; class=&quot;headerlink&quot; title=&quot;1. npm原地址&quot;&gt;&lt;/a&gt;1. npm原地址&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
      <category term="node npm" scheme="https://bobliyz.github.io/categories/node-npm/"/>
    
    
  </entry>
  
  <entry>
    <title>ES6规范</title>
    <link href="https://bobliyz.github.io/2018/07/17/ES6%E8%A7%84%E8%8C%83/"/>
    <id>https://bobliyz.github.io/2018/07/17/ES6规范/</id>
    <published>2018-07-17T08:20:15.000Z</published>
    <updated>2018-07-18T03:11:45.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6篇"><a href="#ES6篇" class="headerlink" title="++ES6篇++"></a>++<strong>ES6篇</strong>++</h2><p><strong>一、类型规范</strong></p><hr><p>对于常量或不修改的变量声明使用const，对于只在当前作用域下有效的变量，应使用let，全局变量使用var。将所有 const 变量放在一起，然后将所有 let 变量放在一起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const foo = 1;</span><br><span class="line">let foo1 = 2;</span><br><span class="line">let bar = foo;</span><br><span class="line">bar = 9;</span><br><span class="line">foo1 = 3;</span><br><span class="line">console.log(foo, bar); // =&gt; 1, 9</span><br><span class="line">console.log(foo, bar, str); // =&gt; 1, 9,&apos;ouven&apos;</span><br></pre></td></tr></table></figure><p>const和let使用时注意，let 和 const 都是块作用域的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// const and let only exist in the blocks they are defined in.</span><br><span class="line">&#123;</span><br><span class="line">  let a = 1;</span><br><span class="line">  const b = 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); // ReferenceError</span><br><span class="line">console.log(b); // ReferenceError</span><br></pre></td></tr></table></figure><p><strong>二、字符串</strong></p><hr><p>使用单引号 ‘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var name = &quot;Bob Parr&quot;;</span><br><span class="line">// good</span><br><span class="line">var name = &apos;Bob Parr&apos;;</span><br><span class="line">// bad</span><br><span class="line">var fullName = &quot;Bob &quot; + this.lastName;</span><br><span class="line">// good</span><br><span class="line">var fullName = &apos;Bob &apos; + this.lastName;</span><br></pre></td></tr></table></figure><p>超过80个字符的字符串应该使用字符串连接换行 注：如果过度使用长字符串连接可能会对性能有影响。jsPerf &amp; Discussion</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var errorMessage = &apos;This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.&apos;;</span><br><span class="line">// bad</span><br><span class="line">var errorMessage = &apos;This is a super long error that \</span><br><span class="line">was thrown because of Batman. \</span><br><span class="line">When you stop to think about \</span><br><span class="line">how Batman had anything to do \</span><br><span class="line">with this, you would get nowhere \</span><br><span class="line">fast.&apos;;</span><br><span class="line">// good</span><br><span class="line">var errorMessage = &apos;This is a super long error that &apos; +</span><br><span class="line">  &apos;was thrown because of Batman.&apos; +</span><br><span class="line">  &apos;When you stop to think about &apos; +</span><br><span class="line">  &apos;how Batman had anything to do &apos; +</span><br><span class="line">  &apos;with this, you would get nowhere &apos; +</span><br><span class="line">  &apos;fast.&apos;;</span><br></pre></td></tr></table></figure><p>编程构建字符串时，使用字符串模板而不是字符串连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">function sayHi(name) &#123;</span><br><span class="line">  return &apos;How are you, &apos; + name + &apos;?&apos;;</span><br><span class="line">&#125;</span><br><span class="line">// bad</span><br><span class="line">function sayHi(name) &#123;</span><br><span class="line">  return [&apos;How are you, &apos;, name, &apos;?&apos;].join();</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">function sayHi(name) &#123;</span><br><span class="line">  return `How are you, $&#123;name&#125;?`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>三、数组类型</strong></p><hr><p>使用字面量语法创建数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">const items = new Array();</span><br><span class="line">// good</span><br><span class="line">const items = [];</span><br></pre></td></tr></table></figure><p>如果你不知道数组的长度，使用 push</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const someStack = [];</span><br><span class="line">// bad</span><br><span class="line">someStack[someStack.length] = &apos;abracadabra&apos;;</span><br><span class="line">// good</span><br><span class="line">someStack.push(&apos;abracadabra&apos;);</span><br></pre></td></tr></table></figure><p>使用 … 来拷贝数组，不要使用 Array.from、Array.of等数组的新的内置API，Array新api用于适合的场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">const len = items.length;</span><br><span class="line">const itemsCopy = [];</span><br><span class="line">let i;</span><br><span class="line">for (i = 0; i &lt; len; i++) &#123;</span><br><span class="line">  itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">const itemsCopy = [...items];</span><br><span class="line">// not good</span><br><span class="line">const foo = [1,2,3];</span><br><span class="line">const nodes = Array.from(foo);</span><br></pre></td></tr></table></figure><p><strong>四、解构 Destructuring</strong></p><hr><p>使用对象的多个属性时请建议使用对象的解构赋值，解构赋值避免了为这些属性创建临时变量或对象。即使转化成es5都是一样的</p><p>嵌套结构的对象层数不能超过3层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// not good</span><br><span class="line">let obj = &#123;</span><br><span class="line">  &apos;one&apos;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &apos;newTwo&apos;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &apos;three&apos;: [</span><br><span class="line">            &apos;four&apos;: &apos;太多层了，头晕晕&apos;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line">// good</span><br><span class="line">let obj = &#123;</span><br><span class="line">  &apos;one&apos;: [</span><br><span class="line">    &apos;two&apos;,</span><br><span class="line">    &#123;</span><br><span class="line">      &apos;twoObj&apos;: &apos;结构清晰&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解构语句中统一不使用圆括号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // not good</span><br><span class="line">[(a)] = [11]; // a未定义</span><br><span class="line">let &#123; a: (b) &#125; = &#123;&#125;; // 解析出错</span><br><span class="line">// good</span><br><span class="line">let [a, b] = [11, 22];</span><br></pre></td></tr></table></figure><p>对象解构</p><p>对象解构元素与顺序无关 对象指定默认值时仅对恒等于undefined ( !== null ) 的情况生效</p><p>若函数形参为对象时，使用对象解构赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> // not good</span><br><span class="line">function someFun(opt) &#123;</span><br><span class="line">  let opt1 = opt.opt1;</span><br><span class="line">  let opt2 = opt.opt2;</span><br><span class="line">  console.log(op1);</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">function someFun(opt) &#123;</span><br><span class="line">  let &#123; opt1, opt2 &#125; = opt;</span><br><span class="line">  console.log(`$(opt1) 加上 $(opt2)`);</span><br><span class="line">&#125;</span><br><span class="line">function someFun(&#123; opt1, opt2 &#125;) &#123;</span><br><span class="line">  console.log(opt1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若函数有多个返回值时，使用对象解构，不使用数组解构，避免添加顺序的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// not good</span><br><span class="line">function anotherFun() &#123;</span><br><span class="line">  const one = 1, two = 2, three = 3;</span><br><span class="line">  return [one, two, three];</span><br><span class="line">&#125;</span><br><span class="line">const [one, three, two] = anotherFun(); // 顺序乱了</span><br><span class="line">// one = 1, two = 3, three = 2</span><br><span class="line">// good</span><br><span class="line">function anotherFun() &#123;</span><br><span class="line">  const one = 1, two = 2, three = 3;</span><br><span class="line">  return &#123; one, two, three &#125;;</span><br><span class="line">&#125;</span><br><span class="line">const &#123; one, three, two &#125; = anotherFun(); // 不用管顺序</span><br><span class="line">// one = 1, two = 2, three = 3</span><br></pre></td></tr></table></figure><p>已声明的变量不能用于解构赋值（语法错误）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 语法错误</span><br><span class="line">let a;</span><br><span class="line">&#123; a &#125; = &#123; b: 123&#125;;</span><br></pre></td></tr></table></figure><p>数组解构时数组元素与顺序相关</p><p>例如交换数组两个元素的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let x = 1;</span><br><span class="line">let y = 2;</span><br><span class="line">// not good</span><br><span class="line">let temp;</span><br><span class="line">temp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = temp;</span><br><span class="line">// good</span><br><span class="line">[x, y] = [y, x]; // 交换变量</span><br></pre></td></tr></table></figure><p>将数组成员赋值给变量时，使用数组解构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4, 5];</span><br><span class="line">// not good</span><br><span class="line">const one = arr[0];</span><br><span class="line">const two = arr[1];</span><br><span class="line">// good</span><br><span class="line">const [one, two] = arr;</span><br></pre></td></tr></table></figure><p>函数有多个返回值时使用对象解构，而不是数组解构。</p><p>这样你就可以随时添加新的返回值或任意改变返回值的顺序，而不会导致调用失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function processInput(input) &#123;</span><br><span class="line">    // then a miracle occurs</span><br><span class="line">    return [left, right, top, bottom];</span><br><span class="line">  &#125;</span><br><span class="line">  // the caller needs to think about the order of return data</span><br><span class="line">  const [left, __, top] = processInput(input);</span><br><span class="line">  // good</span><br><span class="line">  function processInput(input) &#123;</span><br><span class="line">    // then a miracle occurs</span><br><span class="line">    return &#123; left, right, top, bottom &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  // the caller selects only the data they need</span><br><span class="line">  const &#123; left, right &#125; = processInput(input);</span><br></pre></td></tr></table></figure><p><strong>五、函数</strong></p><hr><p>使用函数声明而不是函数表达式</p><p>函数声明拥有函数名，在调用栈中更加容易识别。并且，函数声明会整体提升，而函数表达式只会提升变量本身。这条规则也可以这样描述，始终使用箭头函数来代替函数表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">const foo = function () &#123;</span><br><span class="line">&#125;;</span><br><span class="line">// good</span><br><span class="line">function foo() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绝对不要在一个非函数块（if，while，等等）里声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但是它们解析不同 注：ECMA-262 把 块 定义为一组语句，函数声明不是一个语句。阅读 ECMA-262 对这个问题的说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">if (currentUser) &#123;</span><br><span class="line">  function test() &#123;</span><br><span class="line">    console.log(&apos;Nope.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">if (currentUser) &#123;</span><br><span class="line">  var test = function test() &#123;</span><br><span class="line">    console.log(&apos;Yup.&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绝对不要把参数命名为 arguments, 这将会覆盖函数作用域内传过来的 arguments 对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">function nope(name, options, arguments) &#123;</span><br><span class="line">  // ...stuff...</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">function yup(name, options, args) &#123;</span><br><span class="line">  // ...stuff...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>永远不要使用 arguments，使用 … 操作符来代替</p><p>… 操作符可以明确指定你需要哪些参数，并且得到的是一个真实的数组，而不是 arguments 这样的类数组对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">function concatenateAll() &#123;</span><br><span class="line">  const args = Array.prototype.slice.call(arguments);</span><br><span class="line">  return args.join(&apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">function concatenateAll(...args) &#123;</span><br><span class="line">  return args.join(&apos;&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用函数参数默认值语法，而不是修改函数的实参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// really bad</span><br><span class="line">function handleThings(opts) &#123;</span><br><span class="line">  opts = opts || &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">// still bad</span><br><span class="line">function handleThings(opts) &#123;</span><br><span class="line">  if (opts === void 0) &#123;</span><br><span class="line">    opts = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">function handleThings(opts = &#123;&#125;) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>六、箭头函数 Arrow Functions</strong></p><hr><p>当必须使用函数表达式时（例如传递一个匿名函数时），请使用箭头函数</p><p>箭头函数提供了更简洁的语法，并且箭头函数中 this 对象的指向是不变的，this 对象绑定定义时所在的对象，这通常是我们想要的。如果该函数的逻辑非常复杂，请将该函数提取为一个函数声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">var fn = function fn(v) &#123;</span><br><span class="line">  return console.log(v);</span><br><span class="line">&#125;;</span><br><span class="line">// good</span><br><span class="line">var fn= (v=&gt;console.log(v));</span><br></pre></td></tr></table></figure><p>箭头函数总是用括号包裹参数，省略括号只适用于单个参数，并且还降低了程序的可读性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">[1, 2, 3].forEach(x =&gt; x * x);</span><br><span class="line">// good</span><br><span class="line">[1, 2, 3].forEach((x) =&gt; x * x);</span><br></pre></td></tr></table></figure><p>立即执行的匿名函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 函数表达式</span><br><span class="line">// immediately-invoked function expression (IIFE)</span><br><span class="line">// good，看起来就很厉害</span><br><span class="line">(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;Welcome to the Internet. Please follow me.&apos;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><strong>七、对象</strong></p><hr><p>使用对象字面量创建对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var item = new Object();</span><br><span class="line">// good</span><br><span class="line">var item = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>不要使用保留字（reserved words）作为键，否则在 IE8 下将出错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> // bad</span><br><span class="line">var superman = &#123;</span><br><span class="line">  class: &apos;superhero&apos;,</span><br><span class="line">  default: &#123; clark: &apos;kent&apos; &#125;,</span><br><span class="line">  private: true</span><br><span class="line">&#125;;</span><br><span class="line">// good</span><br><span class="line">var superman = &#123;</span><br><span class="line">  klass: &apos;superhero&apos;,</span><br><span class="line">  defaults: &#123; clark: &apos;kent&apos; &#125;,</span><br><span class="line">  hidden: true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建对象时使用计算的属性名，而不要在创建对象后使用对象的动态特性，这样可以在同一个位置定义对象的所有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function getKey(k) &#123;</span><br><span class="line">    return `a key named $&#123;k&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line">  // bad</span><br><span class="line">  const obj = &#123;</span><br><span class="line">    id: 5,</span><br><span class="line">    name: &apos;San Francisco&apos;</span><br><span class="line">  &#125;;</span><br><span class="line">  obj[getKey(&apos;enabled&apos;)] = true;</span><br><span class="line">  // good</span><br><span class="line">  const obj = &#123;</span><br><span class="line">    id: 5,</span><br><span class="line">    name: &apos;San Francisco&apos;,</span><br><span class="line">    [getKey(&apos;enabled&apos;)]: true</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>使用定义对象方法的简短形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">const atom = &#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  addValue: function (value) &#123;</span><br><span class="line">    return atom.value + value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// good</span><br><span class="line">const atom = &#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  addValue(value) &#123;</span><br><span class="line">    return atom.value + value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>使用定义对象属性的简短形式，书写起来更加简单，并且可以自描述。这里和es5有些不同，需要注意下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const lukeSkywalker = &apos;Luke Skywalker&apos;;</span><br><span class="line">  // bad</span><br><span class="line">  const obj = &#123;</span><br><span class="line">    lukeSkywalker: lukeSkywalker</span><br><span class="line">  &#125;;</span><br><span class="line">  // good</span><br><span class="line">  const obj = &#123;</span><br><span class="line">    lukeSkywalker</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>将所有简写的属性写在对象定义的最顶部，这样可以更加方便地知道哪些属性使用了简短形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const anakinSkywalker = &apos;Anakin Skywalker&apos;;</span><br><span class="line">const lukeSkywalker = &apos;Luke Skywalker&apos;;</span><br><span class="line">// bad</span><br><span class="line">const obj = &#123;</span><br><span class="line">  episodeOne: 1,</span><br><span class="line">  twoJedisWalkIntoACantina: 2,</span><br><span class="line">  lukeSkywalker,</span><br><span class="line">  episodeThree: 3,</span><br><span class="line">  mayTheFourth: 4,</span><br><span class="line">  anakinSkywalker</span><br><span class="line">&#125;;</span><br><span class="line">// good</span><br><span class="line">const obj = &#123;</span><br><span class="line">  lukeSkywalker,</span><br><span class="line">  anakinSkywalker,</span><br><span class="line">  episodeOne: 1,</span><br><span class="line">  twoJedisWalkIntoACantina: 2,</span><br><span class="line">  episodeThree: 3,</span><br><span class="line">  mayTheFourth: 4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>八、类</strong></p><hr><p>总是使用 class 关键字，避免直接修改 prototype，class 语法更简洁，也更易理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">function Queue(contents = []) &#123;</span><br><span class="line">  this._queue = [...contents];</span><br><span class="line">&#125;</span><br><span class="line">Queue.prototype.pop = function() &#123;</span><br><span class="line">  const value = this._queue[0];</span><br><span class="line">  this._queue.splice(0, 1);</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">class Queue &#123;</span><br><span class="line">  constructor(contents = []) &#123;</span><br><span class="line">    this._queue = [...contents];</span><br><span class="line">  &#125;</span><br><span class="line">  pop() &#123;</span><br><span class="line">    const value = this._queue[0];</span><br><span class="line">    this._queue.splice(0, 1);</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类名与花括号须保留一个空格间距，类中的方法定义时，括号 ) 也须与花括号 { 保留一个空格间距</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// not good</span><br><span class="line">class Foo&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    // constructor</span><br><span class="line">  &#125;</span><br><span class="line">  sayHi()    &#123;</span><br><span class="line">    // 仅保留一个空格间距</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">class Foo &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    // constructor</span><br><span class="line">  &#125;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    // 仅保留一个空格间距</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义类时，方法的顺序如下：</p><ul><li>constructor</li><li>public get/set 公用访问器，set只能传一个参数</li><li>public methods 公用方法，公用相关命名使用小驼峰式写法(lowerCamelCase)</li><li>private get/set 私有访问器，私有相关命名应加上下划线 _ 为前缀</li><li>private methods 私有方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// good</span><br><span class="line">class SomeClass &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    // constructor</span><br><span class="line">  &#125;</span><br><span class="line">  get aval() &#123;</span><br><span class="line">    // public getter</span><br><span class="line">  &#125;</span><br><span class="line">  set aval(val) &#123;</span><br><span class="line">    // public setter</span><br><span class="line">  &#125;</span><br><span class="line">  doSth() &#123;</span><br><span class="line">    // 公用方法</span><br><span class="line">  &#125;</span><br><span class="line">  get _aval() &#123;</span><br><span class="line">    // private getter</span><br><span class="line">  &#125;</span><br><span class="line">  set _aval() &#123;</span><br><span class="line">    // private setter</span><br><span class="line">  &#125;</span><br><span class="line">  _doSth() &#123;</span><br><span class="line">    // 私有方法</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是class类，不使用new</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// not good</span><br><span class="line">function Foo() &#123;</span><br><span class="line">&#125;</span><br><span class="line">const foo = new Foo();</span><br><span class="line">// good</span><br><span class="line">class Foo &#123;</span><br><span class="line">&#125;</span><br><span class="line">const foo = new Foo();</span><br></pre></td></tr></table></figure><p>使用 extends 关键字来继承</p><p>这是一个内置的继承方式，并且不会破坏 instanceof 原型检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">  const inherits = require(&apos;inherits&apos;);</span><br><span class="line">  function PeekableQueue(contents) &#123;</span><br><span class="line">    Queue.apply(this, contents);</span><br><span class="line">  &#125;</span><br><span class="line">  inherits(PeekableQueue, Queue);</span><br><span class="line">  PeekableQueue.prototype.peek = function() &#123;</span><br><span class="line">    return this._queue[0];</span><br><span class="line">  &#125;</span><br><span class="line">  // good</span><br><span class="line">  class PeekableQueue extends Queue &#123;</span><br><span class="line">    peek() &#123;</span><br><span class="line">      return this._queue[0];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>九、模块</strong></p><hr><p>总是在非标准的模块系统中使用标准的 import 和 export 语法，我们总是可以将标准的模块语法转换成支持特定模块加载器的语法。</p><p>推荐使用import和export来做模块加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">const AirbnbStyleGuide = require(&apos;./AirbnbStyleGuide&apos;);</span><br><span class="line">module.exports = AirbnbStyleGuide.es6;</span><br><span class="line">// ok</span><br><span class="line">import AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</span><br><span class="line">export default AirbnbStyleGuide.es6;</span><br><span class="line">// best</span><br><span class="line">import &#123; es6 &#125; from &apos;./AirbnbStyleGuide&apos;;</span><br><span class="line">export default es6;</span><br></pre></td></tr></table></figure><p>import / export 后面采用花括号{ }引入模块的写法时，建议在花括号内左右各保留一个空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// not good</span><br><span class="line">import &#123;lightRed&#125; from &apos;./colors&apos;;</span><br><span class="line">import &#123; lightRed&#125; from &apos;./colors&apos;;</span><br><span class="line">// good</span><br><span class="line">import &#123; lightRed &#125; from &apos;./colors&apos;;</span><br></pre></td></tr></table></figure><p>不要使用通配符 * 的 import，这样确保了一个模块只有一个默认的 export 项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">import * as AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</span><br><span class="line">// good</span><br><span class="line">import AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</span><br></pre></td></tr></table></figure><p>不要直接从一个 import 上 export</p><p>虽然一行代码看起来更简洁，但是有一个明确的 import 和一个明确的 export 使得代码行为更加明确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">// filename es6.js</span><br><span class="line">export default &#123; es6 &#125; from &apos;./airbnbStyleGuide&apos;;</span><br><span class="line">// good</span><br><span class="line">// filename es6.js</span><br><span class="line">import &#123; es6 &#125; from &apos;./AirbnbStyleGuide&apos;;</span><br><span class="line">export default es6;</span><br></pre></td></tr></table></figure><p>多变量要导出时应采用对象解构形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// not good</span><br><span class="line">export const a= &apos;a&apos;;</span><br><span class="line">export const b= &apos;b&apos;;</span><br><span class="line">// good</span><br><span class="line">export const a= &apos;a&apos;;</span><br><span class="line">export const b= &apos;b&apos;;</span><br><span class="line">export default &#123; a, b &#125;;</span><br></pre></td></tr></table></figure><p>导出单一一个类时，确保你的文件名就是你的类名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// file contents</span><br><span class="line">class CheckBox &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">module.exports = CheckBox;</span><br><span class="line">// in some other file</span><br><span class="line">// bad</span><br><span class="line">const CheckBox = require(&apos;./checkBox&apos;);</span><br><span class="line">// bad</span><br><span class="line">const CheckBox = require(&apos;./check_box&apos;);</span><br><span class="line">// good</span><br><span class="line">const CheckBox = require(&apos;./CheckBox&apos;);</span><br></pre></td></tr></table></figure></p><p>导出一个默认小驼峰命名的函数时，文件名应该就是导出的方法名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function makeStyleGuide() &#123;</span><br><span class="line">&#125;</span><br><span class="line">export default makeStyleGuide;</span><br></pre></td></tr></table></figure></p><p>导出单例、函数库或裸对象时，使用大驼峰命名规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const AirbnbStyleGuide = &#123;</span><br><span class="line">  es6: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export default AirbnbStyleGuide;</span><br></pre></td></tr></table></figure></p><p><strong>十、Iterators 和 Generators</strong></p><hr><p>Iterators。性能比较差，对于数组来说大致与Array.prototype.forEach相当，比不过原生的for循环，而且用起来比较麻烦，数组提供了for…of，对象提供了for…in，不推荐使用迭代器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">// bad</span><br><span class="line">var iterator = numbers[Symbol.iterator]();  </span><br><span class="line">var result = iterator.next();</span><br><span class="line">let sum = 0;</span><br><span class="line">while (!result.done) &#123;</span><br><span class="line">  sum += result.value;</span><br><span class="line">  result = iterator.next();  </span><br><span class="line">&#125;  </span><br><span class="line">// good</span><br><span class="line">let sum = 0;</span><br><span class="line">for (let num of numbers) &#123;</span><br><span class="line">  sum += num;</span><br><span class="line">&#125;</span><br><span class="line">sum === 15;</span><br><span class="line">// good</span><br><span class="line">let sum = 0;</span><br><span class="line">numbers.forEach((num) =&gt; sum += num);</span><br><span class="line">sum === 15;</span><br><span class="line">// best (use the functional force)</span><br><span class="line">const sum = numbers.reduce((total, num) =&gt; total + num, 0);</span><br><span class="line">sum === 15;</span><br></pre></td></tr></table></figure></p><p>generators。不推荐使用，或者非常谨慎地使用。</p><p>生成器不是用来写异步的，虽然确实有这样一个效果，但这仅仅是一种Hack。异步在未来一定是属于async和await这两个关键字的，但太多人眼里生成器就是写异步用的，这会导致滥用。暂时推荐用promise来实现异步。</p><p><strong>十一、属性访问</strong></p><hr><p>使用点 . 操作符来访问常量属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const luke = &#123;</span><br><span class="line">  jedi: true,</span><br><span class="line">  age: 28</span><br><span class="line">&#125;;</span><br><span class="line">// bad</span><br><span class="line">const isJedi = luke[&apos;jedi&apos;];</span><br><span class="line">// good</span><br><span class="line">const isJedi = luke.jedi;</span><br></pre></td></tr></table></figure><p>使用中括号[] 操作符来访问变量属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var luke = &#123;</span><br><span class="line">  jedi: true,</span><br><span class="line">  age: 28</span><br><span class="line">&#125;;</span><br><span class="line">function getProp(prop) &#123;</span><br><span class="line">  return luke[prop];</span><br><span class="line">&#125;</span><br><span class="line">var isJedi = getProp(&apos;jedi&apos;);</span><br></pre></td></tr></table></figure></p><p><strong>十二、map + set + weakmap + weakset 数据结构</strong></p><hr><p>新加的集合类型，提供了更加方便的获取属性值的方法，可以检查某个属性是属于原型链上还是当前对象的，并用获取对象的set和get方法</p><p>但是，推荐使用weakmap和weakset，而不是map和set，除非必须使用。普通集合会阻止垃圾回收器对这些作为属性键存在的对象的回收，有造成内存泄漏的危险<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// not good, Maps</span><br><span class="line">var wm = new Map();</span><br><span class="line">wm.set(key, &#123; extra: 42 &#125;);</span><br><span class="line">wm.size === 1</span><br><span class="line">// not good, Sets</span><br><span class="line">var ws = new Set();</span><br><span class="line">ws.add(&#123; data: 42 &#125;);</span><br><span class="line">// good, Weak Maps</span><br><span class="line">var wm = new WeakMap();</span><br><span class="line">wm.set(key, &#123; extra: 42 &#125;);</span><br><span class="line">wm.size === undefined</span><br><span class="line">// good, Weak Sets</span><br><span class="line">var ws = new WeakSet();</span><br><span class="line">ws.add(&#123; data: 42 &#125;);//因为添加到ws的这个临时对象没有其他变量引用它，所以ws不会保存它的值，也就是说这次添加其实没有意思</span><br><span class="line">// not good</span><br><span class="line">let object = &#123;&#125;,</span><br><span class="line">object.hasOwnProperty(key)</span><br><span class="line">// good</span><br><span class="line">let object = new WeakSet();</span><br><span class="line">object.has(key) === true;</span><br></pre></td></tr></table></figure></p><ul><li><p>当你的元素或者键值有可能不是字符串时，推荐使用WeakMap和WeakSet。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var obj = &#123; 3:&apos;value&apos; &#125;;</span><br><span class="line">// good</span><br><span class="line">var ws = new WeakSet();</span><br><span class="line">ws.add(3, &apos;value&apos;);</span><br></pre></td></tr></table></figure></li><li><p>有移除操作的需求时，使用WeakMap和WeakSet。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var obj = &#123; &apos;key&apos;:&apos;value&apos; &#125;;</span><br><span class="line">delete obj.key;</span><br><span class="line">// good</span><br><span class="line">var ws = new WeakSet();</span><br><span class="line">ws.add(&apos;key&apos;, &apos;value&apos;);</span><br><span class="line">ws.remove(&apos;key&apos;);</span><br></pre></td></tr></table></figure></li><li><p>当仅需要一个不可重复的集合时，使用WeakSet优先于普通对象，而不要使用{foo: true}这样的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var obj = &#123; &apos;key&apos;:&apos;value&apos; &#125;;</span><br><span class="line">// good</span><br><span class="line">var ws = new WeakSet();</span><br><span class="line">ws.add(&apos;key&apos;, &apos;value&apos;);</span><br></pre></td></tr></table></figure></li><li><p>当需要遍历功能时，使用WeakMap和WeakSet，因为其可以简单地使用for..of进行遍历，性能更高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var obj = &#123; key:&apos;value&apos;, key1: &apos;value1&apos; &#125;;</span><br><span class="line">for(var key in obj)&#123;</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">var ws = new WeakSet();</span><br><span class="line">ws.add(&apos;key&apos;, &apos;value&apos;).add(&apos;key1&apos;, &apos;value1&apos;);</span><br><span class="line">for(var key of ws)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>十三、promise、symbols、proxies</strong></p><hr><p>promise是一种异步处理模式。发promise申明和调用分开，推荐异步方式使用Promise。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// not good</span><br><span class="line">(new Promise(resolve, reject)&#123;&#125;)</span><br><span class="line">  .then(cunction()&#123;&#125;,function()&#123;&#125;)</span><br><span class="line">  .then();</span><br><span class="line">// good</span><br><span class="line">var promise = new Primise(function(resolve, reject)&#123;&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(function()&#123;&#125;,function()&#123;]&#125;)</span><br><span class="line">  .then();</span><br></pre></td></tr></table></figure></p><p>symbol用于对象的键和私有属性，使用过于复杂，没有使用必要，容易扰乱外层作用域。总之不要使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// good</span><br><span class="line">function MyClass(privateData) &#123;</span><br><span class="line">  let key = privateData;</span><br><span class="line">&#125;</span><br><span class="line">//not good</span><br><span class="line">const key = Symbol(&apos;key&apos;);</span><br><span class="line">function MyClass(privateData) &#123;</span><br><span class="line">  this[key] = privateData;</span><br><span class="line">&#125;</span><br><span class="line">const object = new MyClass(&quot;hello&quot;)</span><br><span class="line">object[&apos;key&apos;] === undefined //无法访问该属性，因为是私有的</span><br></pre></td></tr></table></figure><p>Proxy可以监听对象身上发生了什么事情，并在这些事情发生后执行一些相应的操作，没有特别要注意的，尽情用吧。</p><p><strong>十四、不要使用统一码</strong></p><hr><p>字符串支持新的Unicode文本形式，也增加了新的正则表达式修饰符u来处理码位，但是一般不要这样处理，会减低程序可读性且处理统一码速度会降低<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// not good</span><br><span class="line">&apos;字符串&apos;.length == 6</span><br><span class="line">// 新加的：正则支持统一码&apos;u&apos;， 但仍建议不使用</span><br><span class="line">// not good</span><br><span class="line">&apos;字符串&apos;.match(/./u)[0].length == 6</span><br><span class="line">&apos;字符串&apos;.codePointAt(0) == 0x20BB7</span><br></pre></td></tr></table></figure></p><p><strong>十五、进制数支持</strong></p><hr><p>加入对二进制(b)和八进制(o)字面量的支持。该特性可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ok</span><br><span class="line">0b111110111 === 503 // true</span><br><span class="line">0o767 === 503 // true</span><br></pre></td></tr></table></figure><p><strong>十六、不建议使用reflect对象和tail calls尾调用</strong></p><hr><p>没有使用的必要性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ES6篇&quot;&gt;&lt;a href=&quot;#ES6篇&quot; class=&quot;headerlink&quot; title=&quot;++ES6篇++&quot;&gt;&lt;/a&gt;++&lt;strong&gt;ES6篇&lt;/strong&gt;++&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一、类型规范&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;对
      
    
    </summary>
    
      <category term="规范" scheme="https://bobliyz.github.io/categories/%E8%A7%84%E8%8C%83/"/>
    
    
  </entry>
  
  <entry>
    <title>CSS、SASS</title>
    <link href="https://bobliyz.github.io/2018/07/17/CSS%E3%80%81SASS/"/>
    <id>https://bobliyz.github.io/2018/07/17/CSS、SASS/</id>
    <published>2018-07-17T07:09:14.000Z</published>
    <updated>2018-07-18T03:11:49.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-and-Sass-篇"><a href="#CSS-and-Sass-篇" class="headerlink" title="++CSS and Sass 篇++"></a>++CSS and Sass 篇++</h2><p><strong>ID and class naming</strong></p><hr><p>ID和class(类)名总是使用可以反应元素目的和用途的名称，或其他通用名称。代替表象和晦涩难懂的名称。</p><p>应该首选具体和反映元素目的的名称，因为这些是最可以理解的，而且发生变化的可能性最小。</p><p>通用名称只是多个元素的备用名，他们兄弟元素之间是一样的，没有特别意义。<br>区分他们，使他们具有特殊意义，通常需要为“帮手”。</p><p>尽管class(类)名和ID 的语义化对于计算机解析来说没有什么实际的意义，<br>语义化的名称 通常是正确的选择，因为它们所代表的信息含义，不包含表现的限制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//bad</span><br><span class="line">.fw-800 &#123;</span><br><span class="line">  font-weight: 800;</span><br><span class="line">&#125;</span><br><span class="line">.red &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">//good</span><br><span class="line">.heavy &#123;</span><br><span class="line">  font-weight: 800;</span><br><span class="line">&#125;</span><br><span class="line">.important &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>合理的避免使用ID</strong></p><hr><ul><li>一般情况下ID不应该被应用于样式。</li><li>ID的样式不能被复用并且每个页面中你只能使用一次ID。</li><li>使用ID唯一有效的是确定网页或整个站点中的位置。</li><li>尽管如此，你应该始终考虑使用class，而不是id，除非只使用一次</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//bad</span><br><span class="line">#content .title &#123;</span><br><span class="line">  font-size: 2em;</span><br><span class="line">&#125;</span><br><span class="line">//good</span><br><span class="line">.content .title &#123;</span><br><span class="line">  font-size: 2em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个反对使用ID的观点是含有ID选择器权重很高。 </p><p>一个只包含一个ID选择器权重高于包含1000个class(类)名的选择器，这使得它很奇怪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 这个选择器权重高于下面的选择器</span><br><span class="line">#content .title &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">// than this selector!</span><br><span class="line">html body div.content.news-content .title.content-title.important &#123;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CSS选择器中避免标签名</strong></p><hr><p>当构建选择器时应该使用清晰， 准确和有语义的class(类)名。不要使用标签选择器。 如果你只关心你的class(类)名<br>，而不是你的代码元素，这样会更容易维护。</p><p>从分离的角度考虑,在表现层中不应该分配html标记/语义。 </p><p>它可能是一个有序列表需要被改成一个无序列表，或者一个div将被转换成article。 </p><p>如果你只使用具有实际意义的class(类)名，<br>并且不使用元素选择器，那么你只需要改变你的html标记，而不用改动你的CSS。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//bad</span><br><span class="line">div.content &gt; header.content-header &gt; h2.title &#123;</span><br><span class="line">  font-size: 2em;</span><br><span class="line">&#125;</span><br><span class="line">//good</span><br><span class="line">.content &gt; .content-header &gt; .title &#123;</span><br><span class="line">  font-size: 2em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尽可能的精确</strong></p><hr><p>很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。 </p><p>有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。 </p><p>然而，在任何情况下，这是一个非常不好的做法。</p><p>如果你不写很通用的，需要匹配到DOM末端的选择器， 你应该总是考虑直接子选择器。</p><p>考虑下面的DOM:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;article class=&quot;content news-content&quot;&gt;</span><br><span class="line">  &lt;span class=&quot;title&quot;&gt;News event&lt;/span&gt;</span><br><span class="line">  &lt;div class=&quot;content-body&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;title content-title&quot;&gt;</span><br><span class="line">      Check this out</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;p&gt;This is a news article content&lt;/p&gt;</span><br><span class="line">    &lt;div class=&quot;teaser&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;title&quot;&gt;Buy this&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;teaser-content&quot;&gt;Yey!&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/article&gt;</span><br></pre></td></tr></table></figure></p><p>下面的CSS将应用于有title类的全部三个元素。 </p><p>然后，要解决content类下的title类 和 teaser类下的title类下不同的样式，这将需要更精确的选择器再次重写他们的样式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//bad</span><br><span class="line">.content .title &#123;</span><br><span class="line">  font-size: 2rem;</span><br><span class="line">&#125;</span><br><span class="line">//good</span><br><span class="line">.content &gt; .title &#123;</span><br><span class="line">  font-size: 2rem;</span><br><span class="line">&#125;</span><br><span class="line">.content &gt; .content-body &gt; .title &#123;</span><br><span class="line">  font-size: 1.5rem;</span><br><span class="line">&#125;</span><br><span class="line">.content &gt; .content-body &gt; .teaser &gt; .title &#123;</span><br><span class="line">  font-size: 1.2rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缩写属性</strong></p><hr><p>CSS提供了各种缩写属性（如 font 字体）应该尽可能使用，即使在只设置一个值的情况下。</p><p>使用缩写属性对于代码效率和可读性是有很有用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//bad</span><br><span class="line">border-top-style: none;</span><br><span class="line">font-family: palatino, georgia, serif;</span><br><span class="line">font-size: 100%;</span><br><span class="line">line-height: 1.6;</span><br><span class="line">padding-bottom: 2em;</span><br><span class="line">padding-left: 1em;</span><br><span class="line">padding-right: 1em;</span><br><span class="line">padding-top: 0;</span><br><span class="line">//good</span><br><span class="line">border-top: 0;</span><br><span class="line">font: 100%/1.6 palatino, georgia, serif;</span><br><span class="line">padding: 0 1em 2em;</span><br></pre></td></tr></table></figure><p><strong>0 和 单位</strong></p><hr><p>省略“0”值后面的单位。不要在0值后面使用单位，除非有值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//bad</span><br><span class="line">padding-bottom: 0px;</span><br><span class="line">margin: 0em;</span><br><span class="line">//good</span><br><span class="line">padding-bottom: 0;</span><br><span class="line">margin: 0;</span><br></pre></td></tr></table></figure></p><p><strong>十六进制表示法</strong></p><hr><p>在可能的情况下，使用3个字符的十六进制表示法。 </p><p>颜色值允许这样表示，<br>3个字符的十六进制表示法更简短。</p><p>始终使用小写的十六进制数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//bad</span><br><span class="line">color: #FF33AA;</span><br><span class="line">//good</span><br><span class="line">color: #f3a;</span><br></pre></td></tr></table></figure><p><strong>ID 和 Class（类） 名的分隔符</strong></p><hr><p>使用连字符（中划线）分隔ID和Class（类）名中的单词。为了增强课理解性，在选择器中不要使用除了连字符（中划线）以为的任何字符（包括没有）来连接单词和缩写。</p><p>另外，作为该标准，预设属性选择器能识别连字符（中划线）作为单词 [attribute|=value] 的分隔符，<br>所以最好的坚持使用连字符作为分隔符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//bad</span><br><span class="line">.demoimage &#123;&#125;</span><br><span class="line">.error_status &#123;&#125;</span><br><span class="line">//good</span><br><span class="line">#video-id &#123;&#125;</span><br><span class="line">.ads-sample &#123;&#125;</span><br></pre></td></tr></table></figure></p><p><strong>声明顺序</strong></p><hr><p>这是一个选择器内书写CSS属性顺序的大致轮廓。这是为了保证更好的可读性和可扫描重要。</p><p>作为最佳实践，我们应该遵循以下顺序（应该按照下表的顺序）：</p><ol><li>结构性属性：<ul><li>display </li><li>position, left, top, right etc.</li><li>overflow, float, clear etc.</li><li>margin, padding</li></ul></li><li>表现性属性： <ul><li>background, border etc. </li><li>font, text</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//bad</span><br><span class="line">.box &#123;</span><br><span class="line">  font-family: &apos;Arial&apos;, sans-serif;</span><br><span class="line">  border: 3px solid #ddd;</span><br><span class="line">  left: 30%;</span><br><span class="line">  position: absolute;</span><br><span class="line">  text-transform: uppercase;</span><br><span class="line">  background-color: #eee;</span><br><span class="line">  right: 30%;</span><br><span class="line">  isplay: block;</span><br><span class="line">  font-size: 1.5rem;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  padding: 1em;</span><br><span class="line">  margin: 1em;</span><br><span class="line">&#125;</span><br><span class="line">//good</span><br><span class="line">.box &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 30%;</span><br><span class="line">  right: 30%;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  margin: 1em;</span><br><span class="line">  padding: 1em;</span><br><span class="line">  background-color: #eee;</span><br><span class="line">  border: 3px solid #ddd;</span><br><span class="line">  font-family: &apos;Arial&apos;, sans-serif;</span><br><span class="line">  font-size: 1.5rem;</span><br><span class="line">  text-transform: uppercase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明结束</strong></p><hr><p>为了保证一致性和可扩展性，每个声明应该用分号结束，每个声明换行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//bad</span><br><span class="line">.test &#123;</span><br><span class="line">  display: block; height: 100px</span><br><span class="line">&#125;</span><br><span class="line">//good</span><br><span class="line">.test &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>选择器和声明分离</strong></p><hr><p>每个选择器和属性声明总是使用新的一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//bad</span><br><span class="line">a:focus, a:active &#123;</span><br><span class="line">  position: relative; top: 1px;</span><br><span class="line">&#125;</span><br><span class="line">//goog</span><br><span class="line">h1,</span><br><span class="line">h2,</span><br><span class="line">h3 &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">  line-height: 1.2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>CSS引号</strong></p><hr><p>属性选择器或属性值用双引号（””），而不是单引号（”）括起来。 </p><p>URI值（url()）不要使用引号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//bad</span><br><span class="line">@import url(&apos;//cdn.com/foundation.css&apos;);</span><br><span class="line">html &#123;</span><br><span class="line">  font-family: &apos;open sans&apos;, arial, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line">body:after &#123;</span><br><span class="line">  content: &apos;pause&apos;;</span><br><span class="line">&#125;</span><br><span class="line">//good</span><br><span class="line">@import url(//cdn.com/foundation.css);</span><br><span class="line">html &#123;</span><br><span class="line">  font-family: &quot;open sans&quot;, arial, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line">body:after &#123;</span><br><span class="line">  content: &quot;pause&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>选择器嵌套 (SCSS)</strong></p><hr><p>在Sass中你可以嵌套选择器，这可以使代码变得更清洁和可读。嵌套所有的选择器，但尽量避免嵌套没有任何内容的选择器。</p><p>如果你需要指定一些子元素的样式属性，而父元素将不什么样式属性，<br>可以使用常规的CSS选择器链。 </p><p>这将防止您的脚本看起来过于复杂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bad</span><br><span class="line">.content &#123;</span><br><span class="line">  display: block;</span><br><span class="line">&#125;</span><br><span class="line">.content &gt; .news-article &gt; .title &#123;</span><br><span class="line">  font-size: 1.2em;</span><br><span class="line">&#125;</span><br><span class="line">//good</span><br><span class="line">instead</span><br><span class="line">.content &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  &gt; .news-article &#123;</span><br><span class="line">    &gt; .title &#123;</span><br><span class="line">      font-size: 1.2em;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上下文媒体查询(SCSS)</strong></p><hr><p>在Sass中，当你嵌套你的选择器时也可以使用上下文媒体查询。 </p><p>在Sass中，你可以在任何给定的嵌套层次中使用媒体查询。 </p><p>由此生成的CSS将被转换，这样的媒体查询将包裹选择器的形式呈现。</p><p>这技术非常方便，<br>有助于保持媒体查询属于的上下文。</p><p>第一种方法这可以让你先写你的手机样式，然后在任何你需要的地方 </p><p>用上下文媒体查询以提供桌面样式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//bad</span><br><span class="line">.content-page &#123;</span><br><span class="line">  font-size: 1.2rem;</span><br><span class="line">  &gt; .main &#123;</span><br><span class="line">    background-color: whitesmoke;</span><br><span class="line">    &gt; .latest-news &#123;</span><br><span class="line">      padding: 1rem;</span><br><span class="line">      &gt; .news-article &#123;</span><br><span class="line">        padding: 1rem;</span><br><span class="line">        &gt; .title &#123;</span><br><span class="line">          font-size: 2rem;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &gt; .content &#123;</span><br><span class="line">      margin-top: 2rem;</span><br><span class="line">      padding: 1rem;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &gt; .page-footer &#123;</span><br><span class="line">    margin-top: 2rem;</span><br><span class="line">    font-size: 1rem;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (min-width: 641px) &#123;</span><br><span class="line">  .content-page &#123;</span><br><span class="line">    font-size: 1rem;</span><br><span class="line">    &gt; .main &gt; .latest-news &gt; .news-article &gt; .title &#123;</span><br><span class="line">      font-size: 3rem;</span><br><span class="line">    &#125;</span><br><span class="line">    &gt; .page-footer &#123;</span><br><span class="line">      font-size: 0.8rem;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//good</span><br><span class="line">.content-page &#123;</span><br><span class="line">  font-size: 1.2rem;</span><br><span class="line">  @media screen and (min-width: 641px) &#123;</span><br><span class="line">    font-size: 1rem;</span><br><span class="line">  &#125;</span><br><span class="line">  &gt; .main &#123;</span><br><span class="line">    background-color: whitesmoke;</span><br><span class="line">    &gt; .latest-news &#123;</span><br><span class="line">      padding: 1rem;</span><br><span class="line">      &gt; .news-article &#123;</span><br><span class="line">        padding: 1rem;</span><br><span class="line">        &gt; .title &#123;</span><br><span class="line">          font-size: 2rem;</span><br><span class="line">          @media screen and (min-width: 641px) &#123;</span><br><span class="line">            font-size: 3rem;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &gt; .content &#123;</span><br><span class="line">      margin-top: 2rem;</span><br><span class="line">      padding: 1rem;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &gt; .page-footer &#123;</span><br><span class="line">    margin-top: 2rem;</span><br><span class="line">    font-size: 1rem;</span><br><span class="line">    @media screen and (min-width: 641px) &#123;</span><br><span class="line">      font-size: 0.8rem;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>嵌套顺序和父级选择器(SCSS)</strong></p><hr><p>当使用Sass的嵌套功能的时候，<br>重要的是有一个明确的嵌套顺序， </p><p>以下内容是一个SCSS块应具有的顺序。 </p><ol><li>当前选择器的样式属性 </li><li>父级选择器的伪类选择器 (:first-letter, :hover, :active etc) </li><li>伪类元素 (:before and :after) </li><li>父级选择器的声明样式 (.selected, .active, .enlarged etc.) </li><li>用Sass的上下文媒体查询 </li><li>子选择器作为最后的部分</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">.product-teaser &#123;</span><br><span class="line">  // 1. Style attributes</span><br><span class="line">  display: inline-block;</span><br><span class="line">  padding: 1rem;</span><br><span class="line">  background-color: whitesmoke;</span><br><span class="line">  color: grey;</span><br><span class="line">  // 2. Pseudo selectors with parent selector</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: black;</span><br><span class="line">  &#125;</span><br><span class="line">  // 3. Pseudo elements with parent selector</span><br><span class="line">  &amp;:before &#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display: block;</span><br><span class="line">    border-top: 1px solid grey;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;:after &#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display: block;</span><br><span class="line">    border-top: 1px solid grey;</span><br><span class="line">  &#125;</span><br><span class="line">  // 4. State classes with parent selector</span><br><span class="line">  &amp;.active &#123;</span><br><span class="line">    background-color: pink;</span><br><span class="line">    color: red;</span><br><span class="line">    // 4.2. Pseuso selector in state class selector</span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">      color: darkred;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 5. Contextual media queries</span><br><span class="line">  @media screen and (max-width: 640px) &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    font-size: 2em;</span><br><span class="line">  &#125;</span><br><span class="line">  // 6. Sub selectors</span><br><span class="line">  &gt; .content &gt; .title &#123;</span><br><span class="line">    font-size: 1.2em;</span><br><span class="line">    // 6.5. Contextual media queries in sub selector</span><br><span class="line">    @media screen and (max-width: 640px) &#123;</span><br><span class="line">      letter-spacing: 0.2em;</span><br><span class="line">      text-transform: uppercase;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS-and-Sass-篇&quot;&gt;&lt;a href=&quot;#CSS-and-Sass-篇&quot; class=&quot;headerlink&quot; title=&quot;++CSS and Sass 篇++&quot;&gt;&lt;/a&gt;++CSS and Sass 篇++&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;ID and
      
    
    </summary>
    
      <category term="规范" scheme="https://bobliyz.github.io/categories/%E8%A7%84%E8%8C%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://bobliyz.github.io/2018/07/17/hello-world/"/>
    <id>https://bobliyz.github.io/2018/07/17/hello-world/</id>
    <published>2018-07-17T01:31:00.168Z</published>
    <updated>2018-07-17T07:33:12.148Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
